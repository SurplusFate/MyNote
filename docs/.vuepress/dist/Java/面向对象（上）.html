<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.46" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://SurplusFate.github.io/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html"><meta property="og:site_name" content="空~"><meta property="og:title" content="面向对象（上）"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-07-09T00:45:04.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:published_time" content="2022-07-07T00:00:00.000Z"><meta property="article:modified_time" content="2022-07-09T00:45:04.000Z"><title>面向对象（上） | 空~</title><meta name="description" content="学习记录">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.69b2a7a8.css">
    <link rel="modulepreload" href="/assets/app.f98c6153.js"><link rel="modulepreload" href="/assets/面向对象（上）.html.23c32893.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/面向对象（上）.html.60bb20fd.js"><link rel="prefetch" href="/assets/index.html.a719735f.js"><link rel="prefetch" href="/assets/index.html.c55fc647.js"><link rel="prefetch" href="/assets/Java程序的基本规则.html.b3307308.js"><link rel="prefetch" href="/assets/Java语言概述与开发环境.html.2f56855f.js"><link rel="prefetch" href="/assets/数据类型.html.f5c300c0.js"><link rel="prefetch" href="/assets/数组的常见算法.html.26ea2f4e.js"><link rel="prefetch" href="/assets/流程控制与数组.html.36c0377f.js"><link rel="prefetch" href="/assets/第一个java程序.html.e0664a06.js"><link rel="prefetch" href="/assets/运算符.html.a4a1d618.js"><link rel="prefetch" href="/assets/index.html.45878bfd.js"><link rel="prefetch" href="/assets/404.html.7d6f7149.js"><link rel="prefetch" href="/assets/index.html.b8808a5e.js"><link rel="prefetch" href="/assets/index.html.a0f36a18.js"><link rel="prefetch" href="/assets/Java程序的基本规则.html.2c983e14.js"><link rel="prefetch" href="/assets/Java语言概述与开发环境.html.43553987.js"><link rel="prefetch" href="/assets/数据类型.html.e164b2b0.js"><link rel="prefetch" href="/assets/数组的常见算法.html.c0dd0363.js"><link rel="prefetch" href="/assets/流程控制与数组.html.7ab7b051.js"><link rel="prefetch" href="/assets/第一个java程序.html.39db8126.js"><link rel="prefetch" href="/assets/运算符.html.2415b4b5.js"><link rel="prefetch" href="/assets/index.html.8ecf3cc2.js"><link rel="prefetch" href="/assets/404.html.39dc8e60.js"><link rel="prefetch" href="/assets/404.f099e4b9.js"><link rel="prefetch" href="/assets/Layout.7536d76b.js"><link rel="prefetch" href="/assets/Slide.81080788.js"><link rel="prefetch" href="/assets/auto.esm.db7ed181.js"><link rel="prefetch" href="/assets/index.1cde1b34.js"><link rel="prefetch" href="/assets/index.05015614.js"><link rel="prefetch" href="/assets/mermaid.esm.min.5bf04e3f.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/reveal.esm.99143a06.js"><link rel="prefetch" href="/assets/photoswipe.esm.673a3da5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="空~"><!----><span class="site-name hide-in-pad">空~</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="学习指南"><span class="icon iconfont icon-creative" style=""></span>学习指南<!----></a></div><div class="nav-item hide-in-mobile"><a href="/Java/Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html" class="nav-link" aria-label="Java"><span class="icon iconfont icon-java" style=""></span>Java<!----></a></div><div class="nav-item hide-in-mobile"><a href="/MySQL" class="nav-link" aria-label="MySQL"><span class="icon iconfont icon-mysql" style=""></span>MySQL<!----></a></div><div class="nav-item hide-in-mobile"><a href="/前端" class="nav-link" aria-label="前端"><span class="icon iconfont icon-html" style=""></span>前端<!----></a></div><div class="nav-item hide-in-mobile"><a href="/JavaWeb" class="nav-link" aria-label="Java Web"><span class="icon iconfont icon-Apache" style=""></span>Java Web<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="SSM"><span class="title"><span class="icon iconfont icon-tag" style=""></span>SSM</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/SSM/Mybatis" class="nav-link" aria-label="Mybatis"><span class="icon iconfont icon-stack" style=""></span>Mybatis<!----></a></li><li class="dropdown-item"><a href="/SSM/Spring" class="nav-link" aria-label="Spring"><span class="icon iconfont icon-leaf" style=""></span>Spring<!----></a></li><li class="dropdown-item"><a href="/SSM/SpringMVC" class="nav-link" aria-label="SpringMVC"><span class="icon iconfont icon-module" style=""></span>SpringMVC<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/SpringBoot" class="nav-link" aria-label="SpringBoot"><span class="icon iconfont icon-stack" style=""></span>SpringBoot<!----></a></div><div class="nav-item hide-in-mobile"><a href="/SpringCloud" class="nav-link" aria-label="SpringCloud"><span class="icon iconfont icon-stack" style=""></span>SpringCloud<!----></a></div><div class="nav-item hide-in-mobile"><a href="/%E8%B5%84%E6%BA%90/" class="nav-link" aria-label="资源"><span class="icon iconfont icon-free" style=""></span>资源<!----></a></div></nav><!----></div><div class="navbar-right"><!----><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/SurplusFate/SurplusFate.github.io" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/Java/Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html" class="nav-link sidebar-link sidebar-page" aria-label="Java语言概述与开发环境"><span class="icon iconfont icon-note" style=""></span>Java语言概述与开发环境<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Java/%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第一个java程序"><span class="icon iconfont icon-note" style=""></span>第一个java程序<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Java/Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99.html" class="nav-link sidebar-link sidebar-page" aria-label="Java程序的基本规则"><span class="icon iconfont icon-note" style=""></span>Java程序的基本规则<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="数据类型"><span class="icon iconfont icon-note" style=""></span>数据类型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Java/%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-link sidebar-link sidebar-page" aria-label="运算符"><span class="icon iconfont icon-note" style=""></span>运算符<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Java/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E7%BB%84.html" class="nav-link sidebar-link sidebar-page" aria-label="流程控制与数组"><span class="icon iconfont icon-note" style=""></span>流程控制与数组<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Java/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="数组的常见算法"><span class="icon iconfont icon-note" style=""></span>数组的常见算法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="面向对象（上）"><span class="icon iconfont icon-note" style=""></span>面向对象（上）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#类和对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类和对象"><!---->类和对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#定义类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="定义类"><!---->定义类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#对象的产生和使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象的产生和使用"><!---->对象的产生和使用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#对象、引用和指针" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象、引用和指针"><!---->对象、引用和指针<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#对象的this引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象的this引用"><!---->对象的this引用<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#方法详解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法详解"><!---->方法详解<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#方法的参数传递机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法的参数传递机制"><!---->方法的参数传递机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#形参个数可变的方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="形参个数可变的方法"><!---->形参个数可变的方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#递归方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="递归方法"><!---->递归方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#方法重载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法重载"><!---->方法重载<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#成员变量和局部变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="成员变量和局部变量"><!---->成员变量和局部变量<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#成员变量和局部变量-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="成员变量和局部变量"><!---->成员变量和局部变量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#成员变量的初始化和内存中的运行机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="成员变量的初始化和内存中的运行机制"><!---->成员变量的初始化和内存中的运行机制<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-note" style=""></span>面向对象（上）</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://SurplusFate.github.io" target="_blank" rel="noopener noreferrer">空~</a></span><span property="author" content="空~"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月7日</span><meta property="datePublished" content="2022-07-07T00:00:00.000Z"></span><span class="category-info" aria-label="分类🌈" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li class="category category6" role>java</li><meta property="articleSection" content="java"></ul></span><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 45 分钟</span><meta property="timeRequired" content="PT45M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#类和对象" class="router-link-active router-link-exact-active toc-link level2">类和对象</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#定义类" class="router-link-active router-link-exact-active toc-link level3">定义类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#对象的产生和使用" class="router-link-active router-link-exact-active toc-link level3">对象的产生和使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#对象、引用和指针" class="router-link-active router-link-exact-active toc-link level3">对象、引用和指针</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#对象的this引用" class="router-link-active router-link-exact-active toc-link level3">对象的this引用</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#方法详解" class="router-link-active router-link-exact-active toc-link level2">方法详解</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#方法的参数传递机制" class="router-link-active router-link-exact-active toc-link level3">方法的参数传递机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#形参个数可变的方法" class="router-link-active router-link-exact-active toc-link level3">形参个数可变的方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#递归方法" class="router-link-active router-link-exact-active toc-link level3">递归方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#方法重载" class="router-link-active router-link-exact-active toc-link level3">方法重载</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#成员变量和局部变量" class="router-link-active router-link-exact-active toc-link level2">成员变量和局部变量</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#成员变量和局部变量-1" class="router-link-active router-link-exact-active toc-link level3">成员变量和局部变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89.html#成员变量的初始化和内存中的运行机制" class="router-link-active router-link-exact-active toc-link level3">成员变量的初始化和内存中的运行机制</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="面向对象-上" tabindex="-1"><a class="header-anchor" href="#面向对象-上" aria-hidden="true">#</a> 面向对象（上）</h1><p>Java是面向对象的程序设计语言，Java语言提供了定义类、Field、方法等最基本的功能。类可被认为是一种自定义的数据类型，可以使用类来定义变量，所有使用类定义的变量都是引用变量，它们将会引用到类的对象。类用于描述客观世界里某一类对象的共同特征，而对象则是类的具体存在，Java程序使用类的构造器来创建该类的对象。</p><p><strong>面向过程和面向对象的区别</strong>：</p><ol><li><p>面向过程:</p><p>主要关注点是：实现的具体过程，因果关系。</p><p>优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低。</p><p>缺点：采用面向过程的方式开发很难解决非常复杂的业务逻辑，另外面向过程的方式最终导致的软件拓展力差。另外，由于没有独立体的概念，所以无法达到组件的复用。</p></li><li><p>面向对象:</p><p>主要关注点是：主要关注对象能完成那些功能。</p><p>优点：耦合度低，拓展力强。更容易解决现实世界当中更复杂的业务逻辑，组件复用性强。</p><p>缺点：前期投入成本高，需要进行独立体的抽取，大量的系统分析与统计。</p></li></ol><p><strong>面向对象方式</strong>：</p><p>采用面向对象的方式开发一个软件，生命周期当中：（整个生命周期中贯穿使用oo面向对象方式）。</p><ol><li>面向对象的分析：<code>ooa</code></li><li>面向对象的设计：<code>ood</code></li><li>面向对象的编程：<code>oop</code></li></ol><h2 id="类和对象" tabindex="-1"><a class="header-anchor" href="#类和对象" aria-hidden="true">#</a> 类和对象</h2><p>Java是面向对象的程序设计语言，类是面向对象的重要内容，我们可以把类当成一种自定义数据类型，可以使用类来定义变量，这种类型的变量统称为引用变量。也就是说，所有类是引用数据类型。</p><p>类和对象的概念：</p><p>类在现实世界当中是不存在的，是一个模板，是一个概念。是人类大脑思考抽象的结果。</p><p>类代表了一类事物：</p><p>在现实世界当中，对象A与对象B之间具有共同特征，进行抽象总结出一个模板，这个模板被称为类。</p><p>状态-&gt;一个类的属性。</p><p>动作-&gt;一个类的方法。</p><p>对象：对象是实际存在的个体，现实世界当中实际存在。</p><p>实例：对象还有一个名字叫做实例。</p><p>实例化：通过类这个模板创建对象的过程，叫做实例化。</p><p>抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。</p><p><strong>重点</strong>：</p><p>类描述的是对象的共同特征。</p><p>共同特征例如：身高特征</p><p>这个身高特征在访问的时候，必须先创建对象，通过对象去访问这个特征。因为这个特征具体在某个对象上之后，值不同。有的对象身高1.80，有的身高1.9。</p><h3 id="定义类" tabindex="-1"><a class="header-anchor" href="#定义类" aria-hidden="true">#</a> 定义类</h3><p>Java语言里定义类的简单语法如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span>
    零到多个构造器定义<span class="token punctuation">.</span><span class="token punctuation">.</span>
    零到多个<span class="token class-name">Field</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    零到多个方法<span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修饰符可以是public、final、abstract，或者完全省略这三个修饰符，类名只要是一个合法的标识符即可。</p><div class="custom-container warning"><p class="custom-container-title">注意</p><p>如果从程序的可读性方面来看，Java类名必须是由一个或多个有意义的单词连缀而成的，每个单词首字母大写，其他字母全部小写，单词与单词之间不要使用任何分隔符。</p></div><p>对一个类定义而言，可以包含三种最常见的成员：构造器、Field和方法，三种成员都可以定义零个或多个，如果三种成员都只定义零个，就是定义了一个空类，这没有太大的实际意义。</p><p>类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用，但需要指出的是，<mark>static修饰的成员不能访问没有static修饰的成员</mark>。</p><p>Field用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。</p><p>构造器是一个类创建对象的根本途径，如果一个类没有构造器，这个类通常无法创建实例。因此， Java语言提供了一个功能：==如果程序员没有为一个类编写构造器，则系统会为该类提供一个默认的构造器。==一旦程序员为一个类提供了构造器，系统将不再为该类提供构造器。</p><p>定义Field的语法格式如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token class-name">Field</span>类型 <span class="token class-name">Field</span>名 <span class="token punctuation">[</span><span class="token operator">=</span> 默认值<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Field语法格式的详细说明如下。</p><ol><li>修饰符：修饰符可以省略，也可以是public、protected、private、static、final，其中public、protected、private三个最多只能出现其中之一，可以与static、final组合起来修饰Field。</li><li>Field类型：Field类型可以是Java语言允许的任何数据类型，包括基本类型和现在介绍的引用类型。</li><li>Field名：Field名只要是一个合法的标识符即可。</li><li>默认值：定义Field还可以指定一个可选的默认值。</li></ol><div class="custom-container warning"><p class="custom-container-title">注意</p><p>如果从程序可读性角度来看，Field名应该由一个或多个有意义的单词连缀而成，第一个单词首字母小写，后面每个单词首字母大写，其他字母全部小写，单词与单词之间不要使用任何分隔符。</p><p>Field是一种比较难以翻译的名词。有些资料、书籍将Field翻译为属性、字段、域。如果一定要给Field一个准确的中文称呼，可以将其称为“成员变量”——成员变量包括实例变量和类变量。</p></div><p>定义方法的语法格式如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 方法返回值类型方法名 <span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//由零条到多条可执行性语句组成的方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法语法格式的详细说明如下。</p><ol><li>修饰符：修饰符可以省略，也可以是public、protected、private、static、final、abstract，其中public、protected、private三个最多只能出现其中之一；abstract和final最多只能出现其中之一，它们可以与static组合起来修饰方法。</li><li>方法返回值类型：返回值类型可以是Java语言允许的任何数据类型，包括基本类型和引用类型；如果声明了方法返回值类型，则方法体内必须有一个有效的return语句，该语句返回一个变量或一个表达式，这个变量或者表达式的类型必须与此处声明的类型匹配。除此之外，如果一个方法没有返回值，则必须使用void来声明没有返回值。</li><li>方法名：方法名的命名规则与Field命名规则基本相同，但通常建议方法名以英文中的动词开头。</li><li>形参列表：形参列表用于定义该方法可以接受的参数，形参列表由零组到多组“参数类型形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开。一旦在定义方法时指定了形参列表，则调用该方法时必须传入对应的参数值——谁调用方法，谁负责为形参赋值。</li></ol><p>方法体里多条可执行性语句之间有严格的执行顺序，排在方法体前面的语句总是先执行，排在方法体后面的语句总是后执行。</p><p>static是一个特殊的关键字，它可用于修饰方法、Field等成员。static修饰的成员表明它属于这个类本身，而不属于该类的单个实例，因为通常把static修饰的Field和方法也称为类Field、类方法。不使用static修饰的普通方法、Field则属于该类的单个实例，而不属于该类。因为通常把不使用static修饰的Field和方法也称为实例Field、实例方法。</p><p>由于static的英文直译就是静态的意思，因此有时也把static修饰的Field和方法称为静态Field和静态方法，把不使用static修饰的Field和方法称为非静态Field和非静态方法。静态成员不能直接访问非静态成员。</p><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>虽然绝大部分资料都喜欢把static称为静态，但实际上这种说法很模糊，完全无法说明static的真正作用。static的真正作用就是用于区分Field、方法、内部类、初始化块（本书后面会介绍后两种成员）这四种成员到底属于类本身还是属于实例。在类中定义的成员，有static修饰的成员属于类本身，没有static修饰的成员属于该类的实例。</p></div><p>构造器是一个特殊的方法，定义构造器的语法格式与定义方法的语法格式很像，定义构造器的语法格式如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 构造器名 <span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//由零条到多条可执行性语句组成的构造器执行体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构造器语法格式的详细说明如下。</p><ol><li>修饰符：修饰符可以省略，也可以是public、protected、private其中之一。</li><li>构造器名：构造器名必须和类名相同。</li><li>形参列表：和定义方法形参列表的格式完全相同。</li></ol><p>值得指出的是，构造器既不能定义返回值类型，也不能使用void定义构造器没有返回值。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但Java会把这个所谓的构造器当成方法来处理。</p><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>构造器不是没有返回值吗？为什么不能用void修饰呢？</p><p>简单地说，这是Java的语法规定。实际上，类的构造器是有返回值的，当我们用new关键字来调用构造器时，构造器返回该类的实例，可以把这个类的实例当成构造器的返回值，因此构造器的返回值类型总是当前类，无须定义返回值类型。但必须注意：不能在构造器里显式使用return来返回当前类的对象，因为构造器的返回值是隐式的。</p></div><p>定义一个Person类。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
<span class="token comment">//下面定义了两个Field</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token comment">//下面定义了一个say方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的Person类代码里没有定义构造器，系统将为它提供一个默认的构造器，系统提供的构造器总是没有参数的。</p><h3 id="对象的产生和使用" tabindex="-1"><a class="header-anchor" href="#对象的产生和使用" aria-hidden="true">#</a> 对象的产生和使用</h3><p>创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//定义p变量的同时并为p变量赋值</span>
<span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果访问权限允许，类里定义的方法和Field都可以通过类或实例来调用。类或实例访问方法或Field的语法是：类.Field|方法，或者实例.Field|方法，在这种方式中，类或实例是主调者，用于访问该类或该实例的指定Field或方法。</p><p>static修饰的方法和Field，既可通过类来调用，也可通过实例来调用；没有使用static修饰的普通方法和Field，只可通过实例来调用。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//调用p的name Field，直接为该Field赋值</span>
p<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;李刚&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//调用p的say方法，声明say方法时定义了一个形参</span>
<span class="token comment">//调用该方法必须为形参指定一个值</span>
p<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">&quot;Java语言很简单，学习很容易!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//直接输出p的name Field的值，将输出李刚</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中通过Person实例调用了say方法，调用方法时必须为方法的形参赋值。因此在这行代码中调用Person对象的say方法时，必须为say方法传入一个字符串作为形参的参数值，这个字符串将被给content参数。</p><p>大部分时候，定义一个类就是为了重复创建该类的实例，同一个类的多个实例具有相同的特征，而类则是定义了多个实例的共同特征。从某个角度来看，类定义的是多个实例的特征，因此类不是一种具体存在，实例才是具体存在。完全可以这样说：你不是人这个类，我也不是人这个类，我们都只是人的实例。</p><h3 id="对象、引用和指针" tabindex="-1"><a class="header-anchor" href="#对象、引用和指针" aria-hidden="true">#</a> 对象、引用和指针</h3><p>在前面PersonTest.java代码中，有这样一行代码：<code>Person p=new Person();</code>，这行代码创建了一个Person实例，也被称为Person对象，这个Person对象被赋给p变量。</p><p>在这行代码中实际产生了两个东西：一个是p变量，一个是Person对象。</p><p>从Person类定义来看，Person对象应包含两个Field，而Field是需要内存来存储的。因此，当创建Person对象时，必然需要有对应的内存来存储Person对象的Field。</p><p>Person对象由多块内存组成，不同内存块分别存储了Person对象的不同Field。当把这个Person对象赋值给一个引用变量时，系统如何处理呢？难道系统会把这个Person对象在内存里重新复制一份吗？显然不会，Java没有这么笨，Java语言让引用变量指向这个对象即可。也就是说，引用变量里存放的仅仅是一个引用，它指向实际的对象。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071603012.jpeg" alt="img" loading="lazy"></p><p>与前面介绍的数组类型类似，类也是一种引用数据类型，因此程序中定义的Person类型的变量实际上是一个引用，它被存放在栈内存里，指向实际的Person对象；而真正的Person对象则存放在堆（heap）内存中。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071604334.jpeg" alt="img" loading="lazy"></p><p>栈内存里的引用变量并未真正存储对象的Field数据，对象的Field数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度来看，引用变量与C语言里的指针很像，它们都是存储一个地址值，通过这个地址来引用到实际对象。实际上，Java里的引用就是C里的指针，只是Java语言把这个指针封装起来，避免开发者进行烦琐的指针操作。</p><p>当一个对象被创建成功以后，这个对象将保存在堆内存中，Java程序不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象。也就是说，不管是数组还是对象，都只能通过引用来访问它们。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>不管是数组还是对象，当程序访问引用变量的Field或方法时，实际上是访问该引用变量所引用的数组、对象的Field或方法。</p></div><p>堆内存里的对象可以有多个引用，即多个引用变量指向同一个对象。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//将p变量的值赋值给p2变量</span>
<span class="token class-name">Person</span> p2<span class="token operator">=</span>p<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码把p变量的值赋值给p2变量，也就是将p变量保存的地址值赋给p2变量，这样p2变量和p变量将指向堆内存里的同一个Person对象。不管访问p2变量的Field和方法，还是访问p变量的Field和方法，它们实际上是访问同一个Person对象的Field和方法，将会返回相同的访问结果。</p><p>如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，这个对象也就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占的内存区。</p><p>因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可，也就是把这些引用变量赋值为null。</p><h3 id="对象的this引用" tabindex="-1"><a class="header-anchor" href="#对象的this引用" aria-hidden="true">#</a> 对象的this引用</h3><p>Java提供了一个this关键字，this关键字总是指向调用该方法的对象。根据this出现位置的不同， this作为对象的默认引用有两种情形：</p><ol><li>构造器中引用该构造器正在初始化的对象；</li><li>在方法中引用调用该方法的对象。</li></ol><p>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或Field。假设定义了一个Dog类，这个Dog对象的run方法需要调用它的jump方法，那么应该如何做？是否应该定义如下的Dog类呢？</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>
<span class="token comment">//定义一个jump方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在执行jump方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//定义一个run方法，run方法需要借助jump方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Dog</span> d<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        d<span class="token punctuation">.</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;正在执行run方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用这种方式来定义这个Dog类，确实可以实现在run方法中调用jump方法。那么这种做法是否够好呢？下面再提供一个程序来创建Dog对象，并调用该对象的run方法。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DogTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//创建Dog对象</span>
        <span class="token class-name">Dog</span> dog<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用Dog对象的run方法</span>
        dog<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的程序中，一共产生了两个Dog对象，在Dog类的run方法中，程序创建了一个Dog对象，并使用名为d的引用变量来指向该Dog对象；在DogTest的main方法中，程序再次创建了一个Dog对象，并使用名为dog的引用变量来指向该Dog对象。</p><p>这里产生了两个问题。</p><p>第一个问题：在run方法中调用jump方法时是否一定需要一个Dog对象？</p><p>第二个问题：是否一定需要重新创建一个Dog对象？</p><p>第一个问题的答案是肯定的，因为没有使用static修饰的Field和方法都必须使用对象来调用。</p><p>第二个问题的答案是否定的，因为当程序调用run方法时，一定会提供一个Dog对象，这样就可以直接使用这个已经存在的Dog对象，而无须重新创建新的Dog对象了。</p><p>为此，我们需要在run方法中获得调用该方法的对象，通过this关键字就可以满足这个要求。</p><p>this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的对象只能是当前类；<mark>只有当这个方法被调用时，它所代表的对象才被确定下来：谁在调用这个方法，this就代表谁。</mark></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>
<span class="token comment">//定义一个jump方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在执行jump方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//定义一个run方法,run方法需要借助jump方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//使用this引用调用run()方法的对象</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;正在执行run方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在现实世界里，对象的一个方法依赖于另一个方法的情形如此常见：例如，吃饭方法依赖于拿筷子方法，写程序方法依赖于敲键盘方法，这种依赖都是同一个对象两个方法之间的依赖。因此，Java允许对象的一个成员直接调用另一个成员，可以省略this前缀。也就是说，将上面的run方法改为如下形式也完全正确。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;正在执行run方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于static修饰的方法而言，则可以使用类来直接调用该方法，如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。</p><p>所以，static修饰的方法中不能使用this引用。由于static修饰的方法不能使用this引用，所以static修饰的方法不能访问不使用static修饰的普通成员，因此Java语法规定：静态成员不能直接访问非静态成员。</p><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>省略this前缀只是一种假象，虽然程序员省略了调用jump()方法之前的this，但实际上这个this依然是存在的。</p><p>根据汉语语法习惯：完整的语句至少包括主语、谓语、宾语，在面向对象的世界里，主、谓、宾的结构完全成立，例如“猪八戒吃西瓜”是一条汉语语句，转换为面向对象的语法，就可以写成“猪八戒.吃(西瓜);”，因此笔者常常把调用属性、方法的对象称为“主调（主语调用者的简称）”。对于Java语言来说，调用属性、方法时，主调是必不可少的，即使代码中省略了主调，但实际的主调依然存在。一般来说，如果调用static修饰的成员（包括方法、Field）时省略了前面的主调，那么默认使用该类作为主调；如果调用没有static修饰的成员（包括方法、Field）时省略了前面的主调，那么默认使用this作为主调。</p></div><p>下面程序演示了静态方法直接访问非静态方法时引发的错误。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticAccessNonStatic</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;简单的info方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//因为main方法是静态方法，而info是非静态方法</span>
        <span class="token comment">//调用main方法的是该类本身，而不是该类的实例</span>
        <span class="token comment">//因此省略的this无法指向有效的对象</span>
        <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译上面的程序，系统提示在info();代码行出现如下错误：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>无法从静态上下文中引用非静态方法<span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>static修饰的方法属于类，而不属于对象，因此调用static修饰的方法的主调总是类本身；如果允许在static修饰的方法中出现this引用，那将导致this无法引用有效的对象，因此上面程序出现编译错误。</p><p>如果确实需要在静态方法中访问另一个普通方法，则只能重新创建一个对象。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//重新创建一个对象来调用info方法</span>
<span class="token keyword">new</span> <span class="token class-name">StaticAccessNonStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>大部分时候，普通方法访问其他方法、Field时无须使用this前缀，但如果方法里有个局部变量和Field同名，但程序又需要在该方法里访问这个被覆盖的Field，则必须使用this前缀。</p><p>除此之外，this引用也可以用于构造器中作为默认引用，由于构造器是直接使用new关键字来调用，而不是使用对象来调用的，所以this在构造器中引用的是该构造器进行初始化的对象。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThisInConstructor</span><span class="token punctuation">{</span>
    <span class="token comment">//定义一个名为foo的Field</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> foo<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">ThislnConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//在构造器里定义一个foo变量</span>
        <span class="token keyword">int</span> foo<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//使用this代表此构造器进行初始化的对象</span>
        <span class="token comment">//下面的代码将会把刚创建对象的foo Field设置为6</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//所有使用ThisInConstructor创建的对象的foo Field</span>
        <span class="token comment">//都将被设为6，所以下面代码将输出6</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThisInConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与普通方法类似的是，大部分时候，在构造器中访问其他Field和方法时都可以省略this前缀，但如果构造器中有一个与Field同名的局部变量，又必须在构造器中访问这个被覆盖的Field，则必须使用this前缀。</p><p>当this作为对象的默认引用使用时，程序可以像访问普通引用变量一样来访问这个this引用，甚至可以把this当成普通方法的返回值。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReturnThis</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">ReturnThis</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        age<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">//return this，返回调用该方法的对象</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ReturnThis</span> rt<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReturnThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//可以连续调用同一个方法</span>
        rt<span class="token punctuation">.</span><span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;rt的age Field值是:&quot;</span><span class="token operator">+</span> rt<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面程序中可以看出，如果在某个方法中把this作为返回值，则可以多次连续调用同一个方法，从而使得代码更加简洁。但是，这种把this作为返回值的方法可能造成实际意义的模糊，例如上面的grow方法，用于表示对象的生长，即age Field的值加1，实际上不应该有返回值。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>使用this作为方法的返回值可以让代码更加简洁，但可能造成实际意义的模糊。</p></div><h2 id="方法详解" tabindex="-1"><a class="header-anchor" href="#方法详解" aria-hidden="true">#</a> 方法详解</h2><p>方法是类或对象的行为特征的抽象，方法是类或对象最重要的组成部分。但从功能上来看，方法完全类似于传统结构化程序设计里的函数。值得指出的是，Java里的方法不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类，要么属于对象。</p><p>方法就是一段代码片段，并且这段代码片段可以完成某个特定的功能，可以被重复使用。方法定义在类体当中，一个类当中可以定义多个方法，方法编写的位置没有先后顺序，可以随意。</p><p>方法体中不能再定义方法！</p><p>方法体当中的代码遵守自上而下的顺序依次执行。</p><p>永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属，Java语言里的方法也是一样。Java语言里方法的所属性主要体现在如下几个方面。</p><ol><li>方法不能独立定义，方法只能在类体里定义。</li><li>从逻辑意义上来看，方法要么属于该类本身，要么属于该类的一个对象。</li><li>永远不能独立执行方法，执行方法必须使用类或对象作为调用者。</li></ol><h3 id="方法的参数传递机制" tabindex="-1"><a class="header-anchor" href="#方法的参数传递机制" aria-hidden="true">#</a> 方法的参数传递机制</h3><p>如果声明方法时包含了形参声明，则调用方法时必须给这些形参指定参数值，调用方法时实际传给形参的参数值也被称为实参。</p><p>Java里方法的参数传递方式只有一种：值传递。所谓值传递，就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>Java里的参数传递类似于《西游记》里的孙悟空，孙悟空复制了一个假孙悟空，这个假孙悟空具有和孙悟空相同的能力，可除妖或被砍头。但不管这个假孙悟空遇到什么事，真孙悟空不会受到任何影响。与此类似，传入方法的是实际参数值的复制品，不管方法中对这个复制品如何操作，实际参数值本身不会受到任何影响。</p></div><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimitiveTransferTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//下面三行代码实现a、b变量的值交换</span>
        <span class="token comment">//定义一个临时变量来保存a变量的值</span>
        <span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">;</span>
        <span class="token comment">//把b的值赋给a</span>
        a<span class="token operator">=</span>b<span class="token punctuation">;</span>
        <span class="token comment">//把临时变量tmp的值赋给a</span>
        b<span class="token operator">=</span>tmp<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;swap方法里，a的值是&quot;</span><span class="token operator">+</span>a <span class="token operator">+</span> <span class="token string">&quot;;b的值是&quot;</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;交换结束后，变量a的值是&quot;</span><span class="token operator">+</span>a<span class="token operator">+</span><span class="token string">&quot;;变量b的值是&quot;</span><span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//swap方法里，a的值是9;b的值是6</span>
	<span class="token comment">//交换结束后，变量a的值是6;变量b的值是9</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这个运行结果可以看出，main方法里的变量a和b，并不是swap方法里的a和b。正如前面讲的，swap方法的a和b只是main方法里变量a和b的复制品。</p><p>Java程序总是从main方法开始执行，main方法开始定义了a、b两个局部变量。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071937537.jpeg" alt="img" loading="lazy"></p><p>当程序执行swap方法时，系统进入swap方法，并将main方法中的a、b变量作为参数值传入swap方法，传入swap方法的只是a、b的副本，而不是a、b本身，进入swap方法后系统中产生了4个变量。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071938382.jpeg" alt="img" loading="lazy"></p><p>在main方法中调用swap方法时，main方法还未结束。因此，系统分别为main方法和swap方法分配两块栈区，用于保存main方法和swap方法的局部变量。main方法中的a、b变量作为参数值传入swap方法，实际上是在swap方法栈区中重新产生了两个变量a、b，并将main方法栈区中a、b变量的值分别赋给swap方法栈区中的a、b参数（就是对swap方法的a、b形参进行了初始化）。此时，系统存在两个a变量、两个b变量，只是存在于不同的方法栈区中而已。</p><p>程序在swap方法中交换a、b两个变量的值，实际上是对图中灰色覆盖区域的a、b变量进行交换，交换结束后swap方法中输出a、b变量的值，看到a的值为9，b的值为6。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071940269.jpeg" alt="img" loading="lazy"></p><p>两个示意图中main方法栈区中a、b的值并未有任何改变，程序改变的只是swap方法栈区中的a、b。这就是值传递的实质：当系统开始执行方法时，系统为形参执行初始化，就是把实参变量的值赋给方法的形参变量，方法里操作的并不是实际的实参变量。</p><p>前面看到的是基本类型的参数传递，Java对于引用类型的参数传递，一样采用的是值传递方式。但许多初学者可能对引用类型的参数传递会产生一些误会。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">DataWrap</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceTransferTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">DataWrap</span> dw<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//下面三行代码实现dw的a、b两个Field值交换</span>
    <span class="token comment">//定义一个临时变量来保存dw对象的a Field的值</span>
    <span class="token keyword">int</span> tmp<span class="token operator">=</span>dw<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
    <span class="token comment">//把dw对象的b Field的值赋给a Field</span>
    dw<span class="token punctuation">.</span>a<span class="token operator">=</span>dw<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
    <span class="token comment">//把临时变量tmp的值赋给dw对象的b Field</span>
    dw<span class="token punctuation">.</span>b<span class="token operator">=</span>tmp<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;swap方法里,a Field的值是&quot;</span><span class="token operator">+</span>dw<span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token string">&quot;; b Field的值是&quot;</span><span class="token operator">+</span>dw<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">DataWrap</span> dw<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DataWrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dw<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
    dw<span class="token punctuation">.</span>b<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>dw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;交换结束后，a Field的值是&quot;</span><span class="token operator">+</span> dw<span class="token punctuation">.</span>a<span class="token operator">+</span> <span class="token string">&quot;; b Field的值是&quot;</span><span class="token operator">+</span>dw<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// swap方法里,a Field的值是9;b Field的值是6</span>
    <span class="token comment">// 交换结束后，a Field的值是9;b Field的值是6</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面运行结果来看，在swap方法里，a、b两个Field值被交换成功。不仅如此，main方法里swap方法执行结束后，a、b两个Field值也被交换了。这很容易造成一种错觉：调用swap方法时，传入swap方法的就是dw对象本身，而不是它的复制品。但这只是一种错觉。</p><p>程序从main方法开始执行，main方法开始创建了一个<code>DataWrap</code>对象，并定义了一个dw引用变量来指向<code>DataWrap</code>对象，这是一个与基本类型不同的地方。创建一个对象时，系统内存中有两个东西：堆内存中保存了对象本身，栈内存中保存了引用该对象的引用变量。接着程序通过引用来操作<code>DataWrap</code>对象，把该对象的a、b两个Field分别赋值为6、9。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071949370.jpeg" alt="img" loading="lazy"></p><p>接下来，main方法中开始调用swap方法，main方法并未结束，系统会分别开辟出main和swap两个栈区，用于存放main和swap方法的局部变量。调用swap方法时，dw变量作为实参传入swap方法，同样采用值传递方式：把main方法里dw变量的值赋给swap方法里的dw形参，从而完成swap方法的dw形参的初始化。</p><p>main方法中的dw是一个引用，它保存了<code>DataWrap</code>对象的地址值，当把dw的值赋给swap方法的dw形参后，即让swap方法的dw形参也保存这个地址值，即也会引用到堆内存中的<code>DataWrap</code>对象。</p><p>这种参数传递方式是不折不扣的值传递方式，系统一样复制了dw的副本传入swap方法，但关键在于dw只是一个引用变量，所以系统复制了dw变量，但并未复制<code>DataWrap</code>对象。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071952610.jpeg" alt="img" loading="lazy"></p><p>当程序在swap方法中操作dw形参时，由于dw只是一个引用变量，故实际操作的还是堆内存中的<code>DataWrap</code>对象。此时，不管是操作main方法里的dw变量，还是操作swap方法里的dw参数，其实都是操作它所引用的<code>DataWrap</code>对象，它们操作的是同一个对象。因此，当swap方法中交换dw参数所引用<code>DataWrap</code>对象的a、b两个Field值后，我们看到main方法中dw变量所引用<code>DataWrap</code>对象的a、b两个Field值也被交换了。</p><p>为了更好地证明main方法中的dw和swap方法中的dw是两个变量，我们在swap方法的最后一行增加如下代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//把dw直接赋值为null，让它不再指向任何有效地址</span>
dw<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面代码的结果是swap方法中的dw变量不再指向任何有效内存，程序其他地方不做任何修改。main方法调用了swap方法后，再次访问dw变量的a、b两个Field，依然可以输出9、6。可见main方法中的dw变量没有受到任何影响。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207071955387.jpeg" alt="img" loading="lazy"></p><h3 id="形参个数可变的方法" tabindex="-1"><a class="header-anchor" href="#形参个数可变的方法" aria-hidden="true">#</a> 形参个数可变的方法</h3><p>从JDK 1.5之后，Java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的形参。如果在定义方法时，在最后一个形参的类型后增加三点（...），则表明该形参可以接受多个参数值，多个参数值被当成数组传入。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Varargs</span><span class="token punctuation">{</span>
    <span class="token comment">//定义了形参个数可变的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> books<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//books被当成数组处理</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> tmp <span class="token operator">:</span> books<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//输出整数变量a的值</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//调用test方法</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token punctuation">,</span><span class="token string">&quot;疯狂Java讲义&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;轻量级Java EE企业应用实战&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从test的方法体代码来看，形参个数可变的参数其实就是一个数组参数，也就是说，下面两个方法签名的效果完全一样。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//以可变个数形参来定义方法</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> books<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//下面采用数组形参来定义方法</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> books<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种形式都包含了一个名为books的形参，在两个方法的方法体内都可以把books当成数组处理。但区别是调用两个方法时存在差别，对于以可变形参的形式定义的方法，调用方法时更加简洁，如下面代码所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">&quot;疯狂Java讲义&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;轻量级Java EE企业应用实战&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//调用test方法时传入一个数组</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">23</span> <span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token string">&quot;疯狂Java讲义&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;轻量级Java EE企业应用实战&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比两种调用test方法的代码，明显第一种形式更加简洁。实际上，即使是采用形参个数可变的形式来定义方法，调用该方法时也一样可以为个数可变的形参传入一个数组。</p><p>数组形式的形参可以处于形参列表的任意位置，但个数可变的形参只能处于形参列表的最后。也就是说，一个方法中最多只能有一个长度可变的形参。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>长度可变的形参只能处于形参列表的最后。一个方法中最多只能包含一个长度可变的形参。调用包含一个长度可变形参的方法时，这个长度可变的形参既可以传入多个参数，也可以传入一个数组。</p></div><h3 id="递归方法" tabindex="-1"><a class="header-anchor" href="#递归方法" aria-hidden="true">#</a> 递归方法</h3><p>一个方法体内调用它自身，被称为方法递归。方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p><p>例如有如下数学题。已知有一个数列：f(0)=1，f(1)=4，f(n+2)=2*f(n+1)+f(n)，其中n是大于0的整数，求f(10)的值。这个题可以使用递归来求得。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Recursive</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token comment">//方法中调用它自身，就是方法递归</span>
            <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//输出fn(10)的结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的fn方法体中，再次调用了fn方法，这就是方法递归。注意fn方法里调用fn的形式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于fn(10)，即等于2 * fn(9)+fn(8)，其中fn(9)又等于2 * fn(8)+fn(7)……依此类推，最终会计算到fn(2)等于2 * fn(1)+fn(0)，即fn(2)是可计算的，然后一路反算回去，就可以最终得到fn(10)的值。</p><p>当一个方法不断地调用它本身时，必须在某个时刻方法的返回值是确定的，即不再调用它本身，否则这种递归就变成了无穷递归，类似于死循环。因此定义递归方法时有一条最重要的规定：递归一定要向已知方向递归。</p><p>例如，如果把上面数学题改为如此。已知有一个数列：f(20)=1，f(21)=4，f(n+2)=2 * f(n+1)+f(n)，其中n是大于0的整数，求f(10)的值。那么fn的方法体就应该改为如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment">//方法中调用它自身，就是方法递归</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的fn方法来看，当我们要计算fn(10)的值时，fn(10)等于fn(12)-2×fn(11)，而fn(11)等于fn(13)-2×fn(12)……依此类推，直到fn(19)等于fn(21)-2×fn(20)，此时就可以得到fn(19)的值了，然后依次反算到fn(10)的值。这就是递归的重要规则：对于求fn(10)而言，如果fn(0)和fn(1)是已知的，则应该采用fn(n)=2×fn(n-1)+fn(n-2)的形式递归，因为小的一端已知；如果fn(20)和fn(21)是已知的，则应该采用fn(n)=fn(n+2)-2×fn(n+1)的形式递归，因为大的一端已知。</p><p>递归是非常有用的。例如，我们希望遍历某个路径下的所有文件，但这个路径下文件夹的深度是未知的，那么就可以使用递归来实现这个需求。系统可定义一个方法，该方法接受一个文件路径作为参数，该方法可遍历当前路径下的所有文件和文件路径——该方法中再次调用该方法本身来处理该路径下的所有文件路径。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>只要一个方法的方法体实现中再次调用了方法本身，就是递归方法。递归一定要向已知方向递归。</p></div><h3 id="方法重载" tabindex="-1"><a class="header-anchor" href="#方法重载" aria-hidden="true">#</a> 方法重载</h3><p>Java允许同一个类里定义多个同名方法，只要形参列表不同就行。如果同一个类中包含了两个或两个以上方法的方法名相同，但形参列表不同，则被称为方法重载。</p><p>在Java程序中确定一个方法需要三个要素：</p><ol><li>调用者，也就是方法的所属者，既可以是类，也可以是对象；</li><li>方法名，方法的标识；</li><li>形参列表，当调用方法时，系统将会根据传入的实参列表匹配。</li></ol><p>方法重载的要求就是两同一不同：<mark><strong>同一个类中方法名相同，参数列表不同</strong></mark>。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overload</span><span class="token punctuation">{</span>
    <span class="token comment">//下面定义了两个test方法，但方法的形参列表不同</span>
    <span class="token comment">//系统可以区分这两个方法，这被称为方法重载</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;无参数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;重载的test方法&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">Overload</span> ol<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Overload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//调用test时没有传入参数，因此系统调用上面没有参数的test方法</span>
            ol<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//调用test时传入了一个字符串参数</span>
            <span class="token comment">//因此系统调用上面有一个字符串参数的test方法</span>
            ol<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>为什么方法的返回值类型不能用于区分重载的方法？</p><p>对于int f(){}和void f(){}两个方法，如果这样调用int result=f();，系统可以识别是调用返回值类型为int的方法；但Java调用方法时可以忽略方法返回值，如果采用如下方法来调用f();，你能判断是调用哪个方法吗？如果你尚且不能判断，那么Java系统也会糊涂。在编程过程中有一条重要规则：不要让系统糊涂，系统一糊涂，肯定就是你错了。因此，Java里不能使用方法返回值类型作为区分方法重载的依据。</p></div><p>不仅如此，如果被重载的方法里包含了长度可变的形参，则需要注意。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OverloadVarargs</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;只有一个字符串参数的test方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//因为前面已经有了一个test方法,test方法里有一个字符串参数</span>
    <span class="token comment">//此处的长度可变形参里不包含一个字符串参数的形式</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> books<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span><span class="token string">&quot;****形参长度可变的test方法****&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">OverloadVarargs</span> olv<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">OverloadVarargs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//下面两次调用将执行第二个test方法</span>
        olv<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        olv<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span> <span class="token punctuation">,</span> <span class="token string">&quot;bb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//下面调用将执行第一个test方法</span>
        olv<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//下面调用将执行第二个test方法</span>
        olv<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>t <span class="token string">&quot;aa&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果同一个类中定义了test(String... books)方法，同时还定义了一个test(String)方法，如果此时想要调用test(String... books)方法则test(String... books)方法的books不可能通过只传入一个字符串参数实现，如果只传入一个参数，系统会执行重载的test(String)方法。如果需要调用test(String... books)方法，又只想传入一个字符串参数，则可采用传入字符串数组的形式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>olv<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">&quot;aa&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="成员变量和局部变量" tabindex="-1"><a class="header-anchor" href="#成员变量和局部变量" aria-hidden="true">#</a> 成员变量和局部变量</h2><p>在Java语言中，根据定义变量位置的不同，可以将变量分成两大类：成员变量和局部变量。成员变量和局部变量的运行机制存在较大差异。</p><h3 id="成员变量和局部变量-1" tabindex="-1"><a class="header-anchor" href="#成员变量和局部变量-1" aria-hidden="true">#</a> 成员变量和局部变量</h3><p>成员变量指的是在类范围里定义的变量，也就是前面所介绍的Field；局部变量指的是在方法里定义的变量。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>不管是成员变量还是局部变量，都应该遵守相同的命名规则：从语法角度来看，只要是一个合法的标识符即可；但从程序可读性角度来看，应该是多个有意义的单词连缀而成，其中第一个单词首字母小写，后面每个单词首字母大写。</p></div><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202207072036839.jpeg" alt="img" loading="lazy"></p><p>成员变量被分为类Field和实例Field两种，定义Field时没有static修饰的就是实例Field，有static修饰的就是类Field。</p><p>其中类Field从这个类的准备阶段起开始存在，直到系统完全销毁这个类，类Field的作用域与这个类的生存范围相同；而实例Field则从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例Field的作用域与对应实例的生存范围相同。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>一个类在使用之前要经过类加载、类验证、类准备、类解析、类初始化等几个阶段。</p></div><p>正是基于这个原因，我们把类Field和实例Field统称为成员变量，其中类Field可以理解为类成员变量，它作为类本身的一个成员，与类本身共存亡；实例Field则可理解为实例成员变量，它作为实例的一个成员，与实例共存亡。只要类存在，程序就可以访问该类的类Field。在程序中访问类Field通过如下语法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>类<span class="token punctuation">.</span>类<span class="token class-name">Field</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>只要实例存在，程序就可以访问该实例的实例Field。在程序中访问实例Field通过如下语法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>实例<span class="token punctuation">.</span>实例<span class="token class-name">Field</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>类Field也可以让该类的实例来访问。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>实例<span class="token punctuation">.</span>类<span class="token class-name">Field</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但由于这个实例并不拥有这个类Field，因此它访问的并不是这个实例的Field，依然是访问它对应类的类Field。也就是说，如果通过一个实例修改了类Field的值，由于这个类Field并不属于它，而是属于它对应的类。因此，修改的依然是类的类Field，与通过该类来修改类Field的结果完全相同，这会导致该类的其他实例来访问这个类Field时也将获得这个被修改过的值。</p><p>下面程序定义了一个Person类，在这个Person类中定义两个成员变量，一个实例Field：name，以及一个类Field：eyeNum。程序还通过PersonTest类来创建Person实例，并分别通过Person类和Person实例来访问实例Field和类Field。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token comment">//定义一个实例Field</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token comment">//定义一个类Field</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> eyeNum<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonTest</span><span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//Person类已经初始化了，则eyeNum变量起作用了，输出0</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Person的eyeNum类Field值:&quot;</span> <span class="token operator">+</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>eyeNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//创建Person对象</span>
            <span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//通过Person对象的引用p来访问Person对象name实例Field</span>
            <span class="token comment">//并通过实例访问eyeNum类Field</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p变量的name Field值是:&quot;</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot;p对象的eyeNum Field值是:&quot;</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>eyeNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//直接为name实例Field赋值</span>
            p<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;孙悟空&quot;</span><span class="token punctuation">;</span>
            <span class="token comment">//通过p访问eyeNum类Field，依然是访问Person的eyeNum类Field</span>
            p<span class="token punctuation">.</span>eyeNum<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token comment">//再次通过Person对象来访问name实例Field和eyeNum类Field</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p变量的name Field值是:&quot;</span><span class="token operator">+</span>p<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">&quot; p对象的eyeNum Field值是:&quot;</span><span class="token operator">+</span> p<span class="token punctuation">.</span>eyeNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//前面通过p修改了Person的eyeNum，此处的Person.eyeNum将输出2</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Person的eyeNum类Field值:&quot;</span> <span class="token operator">+</span><span class="token class-name">Person</span><span class="token punctuation">.</span>eyeNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Person</span> p2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//p2访问的eyeNum类Field依然引用Person类的，因此依然输出2</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p2对象的eyeNum类Field值:&quot;</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span>eyeNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>成员变量无须显式初始化，只要为一个类定义了类Field或实例Field，系统就会在这个类的准备阶段或创建该类的实例时进行默认初始化，成员变量默认初始化时的赋值规则与数组动态初始化时数组元素的赋值规则完全相同。</p><p>从上面程序运行结果来看，不难发现类Field的作用域比实例Field的作用域更大：实例Field随实例的存在而存在，而类Field则随类的存在而存在。实例也可访问类Field，同一个类的所有实例访问类Field时，实际上访问的是该类本身的同一个Field，也就是说，访问了同一片内存区。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>正如前面提到的，Java允许通过实例来访问static修饰的Field本身就是一个错误，因此读者以后看到通过实例来访问static Field的情形，都可以将它替换成通过类本身来访问static Field的情形，这样程序的可读性、明确性都会大大提高。</p></div><p>局部变量根据定义形式的不同，又可以被分为如下三种。</p><ol><li>形参：在定义方法签名时定义的变量，形参的作用域在整个方法内有效。</li><li>方法局部变量：在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效。</li><li>代码块局部变量：在代码块中定义的局部变量，这个局部变量的作用域从定义该变量的地方生效，到该代码块结束时失效。</li></ol><p>与成员变量不同的是，局部变量除了形参之外，都必须显式初始化。也就是说，必须先给方法局部变量和代码块局部变量指定初始值，否则不可以访问它们。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">{</span>
             <span class="token comment">//定义一个代码块局部变量a</span>
            <span class="token keyword">int</span> a<span class="token punctuation">;</span>
            <span class="token comment">//下面代码将出现错误，因为a变量还未初始化</span>
            <span class="token comment">//System.out.println(&quot;代码块局部变量a的值:&quot; +a);</span>
            <span class="token comment">//为a变量赋初始值，也就是进行初始化</span>
            a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;代码块局部变量a的值:&quot;</span><span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        <span class="token punctuation">}</span>
        <span class="token comment">//下面试图访问的a变量并不存在</span>
    	<span class="token comment">//System.out.println(a);</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面代码中可以看出，只要离开了代码块局部变量所在的代码块，这个局部变量就立即被销毁，变为不可见。</p><p>对于方法局部变量，其作用域从定义该变量开始，直到该方法结束。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodLocalVariableTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//定义一个方法局部变量a</span>
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>
        <span class="token comment">//下面代码将出现错误，因为a变量还未初始化</span>
        <span class="token comment">//System.out.printIn(&quot;方法局部变量a的值:&quot; +a);</span>
        <span class="token comment">//为a变量赋初始值，也就是进行初始化</span>
        a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;方法局部变量a的值:&quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>形参的作用域是整个方法体内有效，而且形参也无须显式初始化，形参的初始化在调用该方法时由系统完成，形参的值由方法的调用者负责指定。</p><p>当通过类或对象调用某个方法时，系统会在该方法栈区内为所有的形参分配内存空间，并将实参的值赋给对应的形参，这就完成了形参的初始化。</p><p>在同一个类里，成员变量的作用范围是整个类内有效，一个类里不能定义两个同名的成员变量，即使一个是类Field，一个是实例Field也不行；一个方法里不能定义两个同名的局部变量，即使一个是方法局部变量，一个是代码块局部变量或者形参也不行。</p><p>Java允许局部变量和成员变量同名，如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可使用this（对于实例Field）或类名（对于类Field）作为调用者来限定访问成员变量。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableOverrideTest</span><span class="token punctuation">{</span>
    <span class="token comment">//定义一个name实例Field</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">&quot;李刚&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">//定义一个price类Field</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> price<span class="token operator">=</span><span class="token number">78.0</span><span class="token punctuation">;</span>
    <span class="token comment">//主方法，程序的入口</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token comment">//方法里的局部变量，局部变量覆盖成员变量</span>
        <span class="token keyword">int</span> price<span class="token operator">=</span><span class="token number">65</span><span class="token punctuation">;</span>
        <span class="token comment">//直接访问price变量，将输出price局部变量的值:65</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//使用类名作为price变量的限定</span>
        <span class="token comment">//将输出price类Field的值:78.0</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">VariableOverrideTest</span><span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//运行info方法</span>
        <span class="token keyword">new</span> <span class="token class-name">VariableOverrideTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token comment">//方法里的局部变量，局部变量覆盖成员变量</span>
        <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">&quot;孙悟空&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">//直接访问name变量，将输出name局部变量的值:&quot;孙悟空&quot;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//使用this来作为name变量的限定</span>
        <span class="token comment">//将输出price实例Field的值:&quot;李刚&quot;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="成员变量的初始化和内存中的运行机制" tabindex="-1"><a class="header-anchor" href="#成员变量的初始化和内存中的运行机制" aria-hidden="true">#</a> 成员变量的初始化和内存中的运行机制</h3><p>当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/SurplusFate/SurplusFate.github.io/edit/main/docs/Java/面向对象（上）.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/9 08:45:04</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1543403469@qq.com">SurplusFate</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/Java/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.html" class="nav-link prev" aria-label="数组的常见算法"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><span class="icon iconfont icon-note" style=""></span>数组的常见算法</div></a><!----></nav><!----><!----><!--]--></main><!--]--><!----><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.f98c6153.js" defer></script>
  </body>
</html>
